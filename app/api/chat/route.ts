// @/app/api/chat/route.ts
import { streamText, tool } from 'ai';
import { createOpenAICompatible } from '@ai-sdk/openai-compatible';
import { z } from 'zod';
import { tavily } from '@tavily/core';
import { giphyTools } from '@/lib/tools/giphy'

const openai2 = createOpenAICompatible({
    name: 'lmstudio',
    baseURL: 'http://89.150.153.77:1234/v1',
});

// Allow streaming responses up to 30 seconds
export const maxDuration = 30;

export async function POST(req: Request) {
    const { messages } = await req.json();

    // Before calling streamText, insert a system instruction to ensure the model 
    // uses the tool result in its final response
    messages.unshift({
        role: 'system',
        content: `You are a helpful English-speaking Learning Assistant with access to various tools. Never use or translate to languages other than English.

# Tool Usage Guidelines
- Use tools when needed to answer user questions
- Always inform the user about what you're doing and why before proceeding
- Always wait for tool results before continuing
- Do not mention specific tool names to users (e.g., say "let me search for that" instead of "using tvlySearch")
- Incorporate tool results into your final response except for saveCourseToBlob (users can view these themselves)
- Never call the same tool multiple times in a row

# Course Creation Process
1. Research: First use tvlySearch to gather information about the requested topic
2. Topic Selection: Use generateTopics to formalize topic suggestions based on research
3. Outline Generation: Use generateCourseOutline providing:
   - A proper goal (default if not provided by user)
   - An audience (assume "beginners" if not specified)
   - At least 3 topics (default to ["Introduction", "Fundamentals", "Advanced Concepts"] if needed)
4. Storage: Save the course generated by generateCourseOutline using saveCourseToBlob so the user can view it
   - When using saveCourseToBlob, DO NOT repeat or output the course content in your response

# Formatting Guidelines
- For lists: add titles above lists, not inside them
- Do not use headings or formatting tags (p, strong) inside list items
- Never nest lists within other lists
- For quotes: 
  - Research using tvlySearch to find genuine quotes with authors and sources
  - Use outputQuote tool to format them properly
  - Format with ">" prefix and place author below the quote

# Other Tool Instructions
- Use imageVision to analyze any user-uploaded images
- Use weather and date tools when appropriate to provide accurate information`,
    });

    const result = streamText({
        model: openai2('qwen2.5-14b-instruct'),
        messages,
        experimental_continueSteps: true,
        temperature: 0.5,
        toolCallStreaming: true,
        onFinish: async (result) => {
            console.log("LLM API Call Result: ", JSON.stringify(result));
        },
        tools: {
            weather: tool({
                description: 'Get the weather in a location (fahrenheit). Do not output the tool call directly but use it in your final user-facing answer.',
                parameters: z.object({
                    location: z.string().describe('The location to get the weather for'),
                }),
                execute: async ({ location }) => {
                    const temperature = Math.round(Math.random() * (90 - 32) + 32);
                    return {
                        location,
                        temperature,
                    };
                },
            }),
            date: tool({
                description: 'Get the current date. Do not output the tool call directly but use it in your final user-facing answer.',
                parameters: z.object({
                    timezone: z.string().describe('The timezone to get the date for'),
                }),
                execute: async ({ timezone }) => {
                    const date = "March 6 2025"
                    return {
                        timezone,
                        date,
                    };
                },
            }),
            tvlySearch: tool({
                description: 'Use Tavily to search the internet. Provide a query for best results. Do not output the tool call directly but use it in your final user-facing answer. Do not output topic related search results directly, but use them to output relevant topics with the generateTopics tool. Do not use this tool for searching GIFs.',
                parameters: z.object({
                    query: z.string().describe('The user search query'),
                }),
                execute: async ({ query }) => {
                    try {
                        const tvlyClient = tavily({ apiKey: process.env.TVLY_API_KEY });
                        const response = await tvlyClient.search(query, {
                            searchDepth: 'advanced',
                            topic: 'general',
                            maxResults: 3,
                            includeImageDescriptions: false,
                            includeAnswer: true,
                            includeRawContent: false,
                            includeDomains: [],
                            excludeDomains: [],
                        });
                        console.log("Tavily response:", response);
                        return response;
                    } catch (error) {
                        console.error("Error in Tavily search:", error);
                        return { error: "Failed to fetch Tavily search results" };
                    }
                },
            }),
            generateTopics: tool({
                description: 'Output topic suggestions based on the user provided request.',
                parameters: z.object({
                    goal: z.string().describe('The goal from the user'),
                    topics: z.array(z.object({
                        topic: z.string().describe('The topic name'),
                        reasoning: z.string().describe('Your reasoning for this topic')
                    })).describe('Array of topics'),
                    reasoning: z.string().describe('Your overall reasoning for the topic selection'),
                }),
                execute: async ({ goal, topics, reasoning }) => {
                    const object = {
                        goal: goal,
                        topics: topics,
                        reasoning: reasoning,
                    }
                    return {
                        response: object,
                        goal: goal,
                        topics: topics,
                        reasoning: reasoning,
                    };
                },
            }),

            generateCourseOutline: tool({
                description: 'Generate a course outline based on user input. Returns a JSON object containing the course structure.',
                parameters: z.object({
                    goal: z.string().default("Learn the fundamentals of AI").describe('The goal of the course'),
                    audience: z.string().default("Beginners").describe('The audience of the course'),
                    topics: z.array(z.string()).default(["Introduction to AI", "Machine Learning Basics", "Deep Learning Concepts"]).describe('The topics to cover'),
                }),

                execute: async ({ goal, audience, topics }) => {
                    try {
                        const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/generateCourseOutline`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ goal, audience, topics }),
                            cache: 'no-store',
                        });

                        // âœ… Read response as JSON instead of text
                        const data = await response.json();

                        console.log("generateCourseOutline API response:", data);

                        return data; // âœ… Return structured JSON directly to the chat agent
                    } catch (error) {
                        console.error("Error executing generateCourseOutline tool:", error);
                        return { error: "An error occurred while generating the course outline." };
                    }
                },
            }),
            imageVision: tool({
                description: 'Analyze an image and provide a description. Provide an image URL to process.',
                parameters: z.object({
                    imageUrl: z.string().describe('The URL of the image to analyze'),
                    prompt: z.string().optional().describe('Optional specific question about the image'),
                }),
                execute: async ({ imageUrl, prompt }) => {
                    try {
                        const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/imageVision`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ imageUrl, prompt }),
                            cache: 'no-store',
                        });

                        const data = await response.json();
                        console.log("Vision API response:", data);
                        return data;
                    } catch (error) {
                        console.error("Error executing vision tool:", error);
                        return { error: "Failed to analyze image" };
                    }
                },
            }),
            outputQuote: tool({
                description: 'Output a quote based on user inquiry. Always use the tvlySearch to find real quotes including their authors and the source, before outputting a quote using this tool.',
                parameters: z.object({
                    quote: z.string().default("inspiration").describe('The topic or theme of the quote'),
                    author: z.string().default("motivational").describe('The style of the quote (e.g., motivational, philosophical, humorous)'),
                    source: z.string().describe('Results from tvlySearch tool')
                }),

                execute: async ({ quote, author, source }) => {
                    try {
                        const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/generateQuote`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ quote, author, source }),
                            cache: 'no-store',
                        });

                        const data = await response.json();
                        console.log("generateQuote API response:", data);
                        return data;
                    } catch (error) {
                        console.error("Error executing generateQuote tool:", error);
                        return { error: "An error occurred while generating the quote." };
                    }
                },
            }),


            saveCourseToBlob: tool({
    description: "Save, retrieve, edit, or list all courses in JSON blob storage",
    parameters: z.object({
        action: z.enum(["save", "get", "edit", "list"]).describe("Action to perform: save, get, edit, or list all courses"),
        title: z.string().optional().describe("Course title (needed for 'save', not 'list' or 'get')"),
        id: z.string().optional().describe("Unique course ID (needed for 'get' and 'edit')"),
        content: z.record(z.string(), z.any()).optional().describe("Course content (for save)"),
        key: z.string().optional().describe("Key to edit (for edit action)"),
        value: z.any().optional().describe("New value (for edit action)"),
    }),
    execute: async ({ action, title, id, content, key, value }) => {
        try {
            console.log("ðŸ”¹ saveCourseToBlob called with:", { action, title, id, content, key, value });

            const BASE_URL = process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
            let response;

            if (action === "save") {
                if (!title || !content) {
                    return { error: "Title and content are required to save a course." };
                }
                console.log("ðŸ“Œ Sending POST request to save new course...");
                response = await fetch(`${BASE_URL}/api/course/blob`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ title, content }),
                });
            } 
            
            else if (action === "get") {
                if (!id) {
                    return { error: "Course ID is required to retrieve a course." };
                }
                console.log(`ðŸ“Œ Sending GET request to fetch course: ${id}`);
                response = await fetch(`${BASE_URL}/api/course/blob?id=${id}`);
            } 
            
            else if (action === "edit") {
                if (!id || !key || value === undefined) {
                    return { error: "Course ID, key, and new value are required for editing." };
                }
                console.log(`ðŸ“Œ Sending PUT request to edit course: ${id}, key: ${key}`);
                response = await fetch(`${BASE_URL}/api/course/blob`, {
                    method: "PUT",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ id, key, value }),
                });
            } 
            
            else if (action === "list") { 
                console.log("ðŸ“Œ Sending GET request to list all courses...");
                response = await fetch(`${BASE_URL}/api/course/blob`);
            } 
            
            else {
                throw new Error("Invalid action specified");
            }

            console.log("ðŸ” Checking API response...");
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`âŒ API Error [${response.status}]:`, errorText);
                return { error: `API Error: ${response.status} - ${errorText}` };
            }

            const data = await response.json();
            console.log("âœ… API Response:", data);

            return data;
        } catch (error) {
            console.error("âŒ Error processing course data:", error);
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            return { error: `Failed to process course data: ${errorMessage}` };
        }
    },
})

            
            
            



            // Commented out streamText tool
            /*
            streamText: tool({
                description: 'An assistant named streamText. Inform the user that the agent answered and then the response',
                parameters: z.object({
                    query: z.string().describe('Your query'),
                }),
                execute: async ({ query }) => {
                    try {
                        const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/streamText`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ query }),
                            cache: 'no-store',
                        });
                
                        // Read the streamed response and construct a usable text output
                        const reader = response.body?.getReader();
                        let resultText = "";
                
                        if (reader) {
                            const decoder = new TextDecoder();
                            let done = false;
                            while (!done) {
                                const { value, done: readerDone } = await reader.read();
                                if (value) resultText += decoder.decode(value, { stream: true });
                                done = readerDone;
                            }
                        }
                
                        return { text: resultText.trim() };
                    } catch (error) {
                        console.error("Error in streamText tool:", error);
                        return { error: "Failed to retrieve streamed text response." };
                    }
                }
            }),
            */

            //...giphyTools({ apiKey: process.env.GIPHY_API_KEY || '' }),
        },
        maxSteps: 30,
    });
    console.log("Tavily API Key:", process.env.TVLY_API_KEY);


    return result.toDataStreamResponse();
}